{
    "collab_server" : "",
    "contents" : "---\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\nSome time ago *Deutsche Bahn*, the German state-owned railway company, started an [Open-Data project](http://data.deutschebahn.com/) including access to their [timetable API](http://data.deutschebahn.com/apis/fahrplan/). At the moment this service is available for long-distance traffic only.\n\nThe REST interface offers XML and JSON data including\n\n* a search for stations,\n* departure boards,\n* arrival boards and\n* journey details on individual trains.\n\nI'll use the JSON data only.\n\nThe team of DB-Open-Date issues API keys to anyone sending an E-Mail to dbopendata@deutschebahn.com.\n\n## Search for stations\n\nThe service `Location.name` supplies the specific IDs to stations matching a certain search string. These `stopID`s as I will call them are needed other services I'll present later. Briefly, you cannot query the API using the name of a station, you'll always need the respective `stopID`.\n\nAssumend you want to know the `stopID` for \"Berlin Hbf\" (*Berlin Main Station*), the respective API call would be:\n\n`https://open-api.bahn.de/bin/rest.exe/location.name?authKey=xxx&lang=de&input=Berlin+Hbf&format=json`\n\nLet's see how I implemented this in R:\n\n```{r include = FALSE}\nauthKey <- \"DBhackFrankfurt0316\"\n```\n```{r message = FALSE}\nlibrary(RJSONIO)\nlibrary(dplyr)\nlibrary(magrittr)\n\ngetStopID <- function(station = \"Berlin Hbf\", authKey) {\n  station %<>% gsub(\" \", \"+\", .)\n  api_url <- paste(\"http://open-api.bahn.de/bin/rest.exe/location.name?authKey=\",authKey,\"&lang=de&input=\",station,\"&format=json\", sep=\"\")\n  stopID_json <- fromJSON(api_url)\n  stopID <- stopID_json$LocationList$StopLocation[[1]][c(\"name\",\"id\")] %>%\n    t() %>%\n    data.frame(stringsAsFactors = FALSE)\n  return(stopID)\n}\n```\n\nAs you can see, `getStopID` requires two arguments: the search pattern (which is \"Berlin Hbf\" by default) and the authentication key `authKey`. Whitespaces in the search pattern get replaced by `+` and then the JSON data is fetched from the API. The API actually provides several results for stations that match the search pattern. So when you look for \"Berlin\" you may get quite a lot of stations and IDs, simply because they have the pattern \"Berlin\" in their names. Therefore I restricted the function to return the first result only, which is always (?) the most obvious or the main station.\n\n```{r}\ngetStopID(\"Berlin\", authKey)\n```\n\nNow we have a `stopID` we can use for further services.\n\n```{r}\nid <- getStopID(\"Berlin\", authKey)$id\n```\n\n## Departure boards\n\nThe `Stationboard` service provides the next 20 departures at a given station (represented by it's `stopID`) at a given time and date. Moreover this service also provides access to train-specific URLS from which journey details of that train can be fetched (-> later!).\n\nSo there are two tasks here: \n\n* Fetch the data and create a departure board\n* Prepare an object containing all train-specific URLs\n\n```{r}\ndepartureBoard <- function(stopID = \"008011160\", date = substr(Sys.time() + 1800, 1, 10), time = substr(Sys.time() + 1800, 12, 16), authKey, refs = FALSE) {\n  time %<>% gsub(\":\",\"%3a\",.)\n  api_url <- paste(\"http://open-api.bahn.de/bin/rest.exe/departureBoard?authKey=\",authKey,\"&lang=de&id=\",stopID,\"&date=\",date,\"&time=\",time,\"&format=json\", sep=\"\")\n  json <- api_url %>% fromJSON()\n  json <- json$DepartureBoard$Departure\n  dep <- data.frame(name = sapply(json, \"[[\", \"name\") %>% as.character() %>% unlist(),\n                    type = sapply(json, \"[[\", \"type\") %>% as.character() %>% unlist(),\n                    stopid = sapply(json, \"[[\", \"stopid\") %>% as.character() %>% unlist(),\n                    stop = sapply(json, \"[[\", \"stop\") %>% as.character() %>% unlist(),\n                    time = sapply(json, \"[[\", \"time\") %>% as.character() %>% unlist(),\n                    date = sapply(json, \"[[\", \"date\") %>% as.character() %>% unlist(),\n                    direction = sapply(json, \"[[\", \"direction\") %>% as.character() %>% unlist(),\n                    track = sapply(json, \"[[\", \"track\") %>% as.character() %>% unlist(),\n                    JourneyDetailRef = sapply(json, \"[[\", \"JourneyDetailRef\") %>% as.character() %>% unlist(),\n                    stringsAsFactors = F)\n  dep[dep == \"NULL\"] <- NA\n  board <- dep %>%\n    select(Date = date, From = stop, To = direction, Time = time, Train = name, Track = track)\n  if (refs == TRUE) {\n    refs <- dep %>%\n      select(Date = date, Time = time, Train = name, Ref = JourneyDetailRef)\n    return(list(departureBoard = board, departureBoardRef = refs))\n  } else {\n    return(board)\n  }\n}\n```\n\nBy default `departurBoard()` looks for trains leaving Berlin Main Station on `Sys.Date()` at `Sys.time()` plus 30 minutes. Further arguments are the necessary `authKey` and a logical value determining whether the train-specific URLs shall be returned or not.\n\nThe way I convert the JSON data to `data.frame` is probably not the fastest one but it avoids trouble with missing values. Once you have the raw data tidied up a bit the actual work is done. As you can see `departureBoard()` returns a `data.frame` representing the departure board when `refs = FALSE` but returns a list containing the departure board and a second table. This additional table holds the train-specific information.\n\n```{r}\ndepartureBoard(authKey = authKey)\n```\n\nFor later, let's store the train-specific information:\n\n```{r}\ndep <- departureBoard(authKey = authKey, refs = TRUE)\n```\n\n## Arrival boards\n\nThis is pretty much the same as `departureBoard()` but providing the next 20 arrivals.\n\n```{r}\narrivalBoard <- function(stopID = \"008011160\", date = substr(Sys.time() + 1800, 1, 10), time = substr(Sys.time() + 1800, 12, 16), authKey, refs = FALSE) {\n  time %<>% gsub(\":\",\"%3a\",.)\n  api_url <- paste(\"http://open-api.bahn.de/bin/rest.exe/arrivalBoard?authKey=\",authKey,\"&lang=de&id=\",stopID,\"&date=\",date,\"&time=\",time,\"&format=json\", sep=\"\")\n  json <- api_url %>% fromJSON()\n  json <- json$ArrivalBoard$Arrival\n  arr <- data.frame(name = sapply(json, \"[[\", \"name\") %>% as.character() %>% unlist(),\n                    type = sapply(json, \"[[\", \"type\") %>% as.character() %>% unlist(),\n                    stopid = sapply(json, \"[[\", \"stopid\") %>% as.character() %>% unlist(),\n                    stop = sapply(json, \"[[\", \"stop\") %>% as.character() %>% unlist(),\n                    time = sapply(json, \"[[\", \"time\") %>% as.character() %>% unlist(),\n                    date = sapply(json, \"[[\", \"date\") %>% as.character() %>% unlist(),\n                    origin = sapply(json, \"[[\", \"origin\") %>% as.character() %>% unlist(),\n                    track = sapply(json, \"[[\", \"track\") %>% as.character() %>% unlist(),\n                    JourneyDetailRef = sapply(json, \"[[\", \"JourneyDetailRef\") %>% as.character() %>% unlist(),\n                    stringsAsFactors = F)\n  arr[arr == \"NULL\"] <- NA\n  board <- arr %>%\n    select(Date = date, Stop = stop, Train = name, From = origin, Time = time, Track = track)\n  if (refs == TRUE) {\n    refs <- arr %>%\n      select(Date = date, Time = time, Train = name, Ref = JourneyDetailRef)\n    return(list(arrivalBoard = board, arrivalBoardRef = refs))\n  } else {\n    return(board)\n  }\n}\n```\n```{r}\narrivalBoard(authKey = authKey)\n```\n\n## Journey details\n\nNow we will take a closer look on that train-specific information I talked about earlier. To any train listed in a departure or arrival board there's a specific URL that calls the `Journey Details` service from the API. There you get more detailed information on the route of the train containing all stops, arrival and departure times as well as the coordinates of the respective stations.\n\nThat's how I used it:\n\n```{r}\njourneyDetails <- function(refs, Train) {\n  ref_url<- refs[refs$Train == Train,]$Ref\n  journey <- ref_url %>%\n    as.character() %>%\n    fromJSON()\n  journey <- journey$JourneyDetail$Stops$Stop\n  journey <- data.frame(name = journey %>% sapply(\"[\", \"name\") %>% as.character(),\n                        id = journey %>% sapply(\"[\", \"id\") %>% as.character(),\n                        lon = journey %>% sapply(\"[\", \"lon\") %>% as.numeric(),\n                        lat = journey %>% sapply(\"[\", \"lat\") %>% as.numeric(),\n                        routeIdx = journey %>% sapply(\"[\", \"routeIdx\") %>% as.numeric(),\n                        arrTime = journey %>% sapply(\"[\", \"arrTime\") %>% as.character(),\n                        arrDate = journey %>% sapply(\"[\", \"arrDate\") %>% as.character(),\n                        depTime = journey %>% sapply(\"[\", \"depTime\") %>% as.character(),\n                        depDate = journey %>% sapply(\"[\", \"depDate\") %>% as.character(),\n                        track = journey %>% sapply(\"[\", \"track\") %>% as.character(),\n                        stringsAsFactors = F)\n  return(journey)\n}\n```\n\n`journeyDetails` requires two arguments: First the stored references and second the name of he respective train. So just take a look back at `dep` and choose a train name:\n\n```{r}\njourneyDetails(dep$departureBoardRef, dep$departureBoardRef$Train[2])\n```\n\nThe returned table lists all stations the train will head for on its way from *Berlin Gesundbrunnen* to *Koblenz Hbf* with the respective arrival and departure times, the order of stops and the stations' coordinates.\n\n## Make some plots\n\n`journeyDetails()` offers the opportunity to plot a train's route on a map including some additional information. For a brief example I will take the journey details from above.\n\n```{r, message = F}\njourney <- journeyDetails(dep$departureBoardRef, dep$departureBoardRef$Train[2])\njourney$time <- ifelse(!is.na(journey$depTime), journey$depTime, journey$arrTime)\n\nlibrary(ggplot2)\nlibrary(ggmap)\nlibrary(ggrepel)\n\nger <- get_map(location = c(5.14,47.13,15.36,55.25), zoom = 6, maptype = \"toner-background\")\n\nggmap(ger) +\n  geom_point(data = journey, aes(x = lon, y = lat), size = 3, colour = \"blue\", alpha= 0.6) +\n  geom_path(data = journey, aes(x = lon, y = lat), size = 1, colour = \"blue\", alpha = 0.4) +\n  geom_text_repel(data = journey, aes(x = lon, y = lat, label = paste(name)), \n                  colour = \"red2\", box.padding = unit(0.2, \"lines\"), fontface = \"bold\", point.padding = unit(0.3, \"lines\"))\n```\n\nWell this is definitely not a nice plot, but it surely reveals the possibilities you have.\n\n## DBopen\n\nIn the next days I'll try to make a package (`DBopen`) out of these functions and maybe add some further functionality. As always: Feel free to contribute!\n",
    "created" : 1462909757450.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2141872620",
    "id" : "FE76550",
    "lastKnownWriteTime" : 1462805390,
    "last_content_update" : 1462805390,
    "path" : "~/R/DBopen.Rmd",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}